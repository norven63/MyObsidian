## Brookçº¿ç¨‹ç›‘æ§æŠ€æœ¯é“¾è·¯ä¸æ ¸å¿ƒæ–¹æ¡ˆè¯¦è§£

### ğŸ—ï¸ æ•´ä½“æ¶æ„

Brookçš„çº¿ç¨‹ç›‘æ§é‡‡ç”¨**åˆ†å±‚ç›‘æ§æ¶æ„**ï¼ŒåŒ…å«ä»¥ä¸‹å‡ ä¸ªæ ¸å¿ƒå±‚æ¬¡ï¼š

1. **ç¼–è¯‘æ—¶æ’æ¡©å±‚** - é€šè¿‡Gradleæ’ä»¶è¿›è¡Œå­—èŠ‚ç æ’æ¡©
2. **Javaå±‚ç›‘æ§** - ç›‘æ§Javaçº¿ç¨‹ç”Ÿå‘½å‘¨æœŸ
3. **Nativeå±‚ç›‘æ§** - ç›‘æ§Nativeçº¿ç¨‹å’Œç³»ç»Ÿè°ƒç”¨
4. **æ•°æ®æ”¶é›†å±‚** - ç»Ÿä¸€æ”¶é›†å’Œå­˜å‚¨ç›‘æ§æ•°æ®
5. **åˆ†æå¤„ç†å±‚** - æ•°æ®åˆ†æå’Œé—®é¢˜æ£€æµ‹

### ğŸ”§ æ ¸å¿ƒæŠ€æœ¯æ–¹æ¡ˆ

#### 1. ç¼–è¯‘æ—¶å­—èŠ‚ç æ’æ¡©

**æŠ€æœ¯å®ç°ï¼š**
- ä½¿ç”¨**ASM**å’Œ**Javassist**è¿›è¡Œå­—èŠ‚ç æ“ä½œ
- é€šè¿‡Gradleæ’ä»¶åœ¨ç¼–è¯‘æ—¶è‡ªåŠ¨æ’æ¡©
- æ”¯æŒå¤šç§çº¿ç¨‹åˆ›å»ºæ–¹å¼çš„ç›‘æ§

**æ’æ¡©ç­–ç•¥ï¼š**

```java
// 1. æ›¿æ¢æ„é€ å‡½æ•°è°ƒç”¨
Thread -> BrookThread
Timer -> BrookTimer
HandlerThread -> BrookHandlerThread

// 2. æ›¿æ¢é™æ€æ–¹æ³•è°ƒç”¨
Executors.newFixedThreadPool() -> BrookExecutors.newFixedThreadPool()

// 3. åœ¨Thread.run()æ–¹æ³•å‰åæ’æ¡©
@Override
public void run() {
    recordRun();        // æ’æ¡©ï¼šçº¿ç¨‹å¼€å§‹è¿è¡Œ
    super.run();       // åŸå§‹runæ–¹æ³•
    recordThreadQuit(); // æ’æ¡©ï¼šçº¿ç¨‹ç»“æŸ
}
```

#### 2. Javaçº¿ç¨‹ç”Ÿå‘½å‘¨æœŸç›‘æ§

**ç›‘æ§ç»´åº¦ï¼š**
- **çº¿ç¨‹åˆ›å»º** - è®°å½•åˆ›å»ºæ—¶é—´ã€åˆ›å»ºè€…ã€å †æ ˆä¿¡æ¯
- **çº¿ç¨‹è¿è¡Œ** - è®°å½•TIDã€ä¼˜å…ˆçº§ã€çŠ¶æ€å˜åŒ–
- **çº¿ç¨‹é”€æ¯** - è®°å½•é”€æ¯æ—¶é—´ã€CPUä½¿ç”¨æƒ…å†µã€ä¸Šä¸‹æ–‡åˆ‡æ¢æ¬¡æ•°

**æ ¸å¿ƒæ•°æ®ç»“æ„ï¼š**
```java
public class JavaThreadRecord extends ThreadRecord {
    private long threadId;           // Javaçº¿ç¨‹ID
    private int priority;            // çº¿ç¨‹ä¼˜å…ˆçº§
    private List<String> createStackTrace;    // åˆ›å»ºæ—¶å †æ ˆ
    private List<String> currentStackTrace; // å½“å‰å †æ ˆ
    private int tid;                // ç³»ç»Ÿçº¿ç¨‹ID
    private long createTimeMillis;  // åˆ›å»ºæ—¶é—´
    private long durationMillis;     // è¿è¡Œæ—¶é•¿
    private float cpuUsage;         // CPUä½¿ç”¨ç‡
    private long voluntaryCtxtSwitches;      // ä¸»åŠ¨ä¸Šä¸‹æ–‡åˆ‡æ¢
    private long nonvoluntaryCtxtSwitches;  // è¢«åŠ¨ä¸Šä¸‹æ–‡åˆ‡æ¢
}
```

#### 3. Nativeçº¿ç¨‹ç›‘æ§

**Hookæœºåˆ¶ï¼š**
```cpp
// Hook pthread_create
int brook_pthread_create(pthread_t *thread, const pthread_attr_t *attr, 
                        void *(*start_routine)(void *), void *arg) {
    if (brook_thread_enabled) {
        // è®°å½•è°ƒç”¨è€…ä¿¡æ¯
        std::string caller_info = getCallerInfo();
        
        // åŒ…è£…åŸå§‹å‡½æ•°
        auto wrapper = new ThreadRoutineArgWrapper();
        wrapper->origin_routine = start_routine;
        wrapper->origin_arg = arg;
        
        // åˆ›å»ºçº¿ç¨‹å¹¶æ³¨å†Œç›‘æ§
        int result = pthread_create(thread, attr, start_routine_wrapper, wrapper);
        ThreadCollector::get_instance().on_create(*thread, gettid(), caller_info);
        return result;
    }
    return pthread_create(thread, attr, start_routine, arg);
}
```

**æ¶ˆæ¯é˜Ÿåˆ—æœºåˆ¶ï¼š**
```cpp
struct ThreadLifecycleMessage {
    int type;  // 0:create, 1:run, 2:quit
    pthread_t thread_t;
    std::variant<std::monostate, int, std::pair<int, std::string>> data;
};

// å¼‚æ­¥å¤„ç†çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸäº‹ä»¶
void ThreadCollector::run() {
    while(true) {
        ThreadLifecycleMessage message = mq_.poll_once();
        // å¤„ç†çº¿ç¨‹åˆ›å»ºã€è¿è¡Œã€é€€å‡ºäº‹ä»¶
        processThreadEvent(message);
    }
}
```

#### 4. é”ç«äº‰ç›‘æ§

**ç›‘æ§ç­–ç•¥ï¼š**
- **synchronizedå—ç›‘æ§** - åœ¨MONITORENTER/MONITOREXITæŒ‡ä»¤å‰åæ’æ¡©
- **synchronizedæ–¹æ³•ç›‘æ§** - åœ¨æ–¹æ³•å¼€å§‹å’Œç»“æŸå¤„æ’æ¡©
- **Lockæ¥å£ç›‘æ§** - æ›¿æ¢Lock.lock()ç­‰æ–¹æ³•çš„è°ƒç”¨

**æ’æ¡©ç¤ºä¾‹ï¼š**
```java
// åŸå§‹ä»£ç 
synchronized(obj) {
    // ä¸šåŠ¡é€»è¾‘
}

// æ’æ¡©åä»£ç 
BrookSynchronized.acquireLockBefore();
synchronized(obj) {
    BrookSynchronized.acquireLockAfter();
    // ä¸šåŠ¡é€»è¾‘
}
```

**é”ç­‰å¾…æ—¶é—´ç»Ÿè®¡ï¼š**
```java
public static void onLockAcquire(long happenTimeMillis, long endTimeMillis) {
    long duration = endTimeMillis - happenTimeMillis;
    if (duration < threshold) return;
    
    LockRecord record = new LockRecord(happenTimeMillis, duration);
    record.stackTrace = StackTraceUtil.currentStackTrace(1);
    
    // å¼‚æ­¥å¤„ç†é”ç­‰å¾…äº‹ä»¶
    Dispatcher.instance().post(() -> {
        if (processor != null) {
            processor.onLockAcquire(record);
        }
    });
}
```

#### 5. æ–¹æ³•è°ƒç”¨è·Ÿè¸ª

**Nativeæ–¹æ³•ç›‘æ§ï¼š**
```java
// åœ¨Nativeæ–¹æ³•è°ƒç”¨å‰åæ’æ¡©
public void nativeMethod() {
    long startTime = SystemClock.elapsedRealtime();
    nativeMethodImpl();  // åŸå§‹Nativeè°ƒç”¨
    MethodTraceCollector.onNativeMethodEnd(className, methodName, startTime);
}
```

**æ€§èƒ½é˜ˆå€¼è¿‡æ»¤ï¼š**
```java
private static void process(String tag, long happenTimeMillis) {
    long duration = SystemClock.elapsedRealtime() - happenTimeMillis;
    if (duration < threshold) return;  // è¿‡æ»¤çŸ­æ—¶é—´è°ƒç”¨
    
    MethodTraceRecord record = new MethodTraceRecord(tag, happenTimeMillis, duration);
    record.setStackTrace(StackTraceUtil.currentStackTrace(2));
    
    // å¼‚æ­¥å¤„ç†æ€§èƒ½æ•°æ®
    dispatcher.post(() -> processor.onMethodEnd(record));
}
```

### ğŸ“Š æ•°æ®æ”¶é›†ä¸åˆ†æ

#### 1. å®æ—¶æ•°æ®æ”¶é›†

**ç³»ç»Ÿä¿¡æ¯è·å–ï¼š**
```java
// ä»/proc/self/taskè·å–çº¿ç¨‹ä¿¡æ¯
File[] threadDirs = new File("/proc/self/task").listFiles();
for (File threadDir : threadDirs) {
    // è§£æ/statæ–‡ä»¶è·å–CPUä½¿ç”¨æƒ…å†µ
    // è§£æ/statusæ–‡ä»¶è·å–ä¸Šä¸‹æ–‡åˆ‡æ¢æ¬¡æ•°
    // è§£æ/commæ–‡ä»¶è·å–çº¿ç¨‹åç§°
}
```

**æ€§èƒ½æŒ‡æ ‡è®¡ç®—ï¼š**
```java
// CPUä½¿ç”¨ç‡è®¡ç®—
long utime = Long.parseLong(statSplit[13]);  // ç”¨æˆ·æ€æ—¶é—´
long stime = Long.parseLong(statSplit[14]);  // å†…æ ¸æ€æ—¶é—´
threadRecord.cpuUsage = (utime + stime) / elapsedCpuTicks;

// ä¸Šä¸‹æ–‡åˆ‡æ¢ç»Ÿè®¡
threadRecord.voluntaryCtxtSwitches = Long.parseLong(statusLine.split(":")[1]);
threadRecord.nonvoluntaryCtxtSwitches = Long.parseLong(statusLine.split(":")[1]);
```

#### 2. å¼‚æ­¥æ•°æ®å¤„ç†

**Dispatcheræœºåˆ¶ï¼š**
```java
public class Dispatcher {
    private static final Handler handler = new Handler(Looper.getMainLooper());
    
    public void post(Runnable runnable) {
        handler.post(runnable);
    }
}
```

**æ•°æ®å­˜å‚¨ï¼š**
```java
// çº¿ç¨‹è®°å½•å­˜å‚¨
private static final Map<String, JavaThreadRecord> sRecordMap = new ConcurrentHashMap<>();

// ç”Ÿå‘½å‘¨æœŸäº‹ä»¶å¤„ç†
public static void onJavaThreadCreate(long createByTid, long id, String name, int priority) {
    Dispatcher.instance().post(() -> {
        JavaThreadRecord record = new JavaThreadRecord(id);
        record.setName(name);
        record.setPriority(priority);
        record.setCreateStackTrace(StackTraceUtil.currentStackTrace(1));
        sRecordMap.put(JavaThreadRecord.constructKey(id), record);
    });
}
```



## çº¿ç¨‹ç›‘æ§æ’æ¡©å®ç°

### 1. çº¿ç¨‹åˆ›å»ºæ’æ¡© - BrookThread

**åŸå§‹ä»£ç ï¼š**
```java
Thread thread = new Thread(runnable);
thread.start();
```

**æ’æ¡©åçš„ä»£ç ï¼š**
```java
// 1. æ„é€ å‡½æ•°æ›¿æ¢
Thread thread = new BrookThread(runnable);  // Thread -> BrookThread

// 2. BrookThreadå®ç°
public class BrookThread extends Thread {
    @Override
    public synchronized void start() {
        if (LifecycleCollector.enabled) {
            // æ’æ¡©ï¼šè®°å½•çº¿ç¨‹åˆ›å»º
            ThreadCollector.onJavaThreadCreate(
                Thread.currentThread().getId(), 
                getId(), 
                getName(), 
                getPriority()
            );
        }
        super.start();
    }

    @Override
    public void run() {
        recordRun();    // æ’æ¡©ï¼šçº¿ç¨‹å¼€å§‹è¿è¡Œ
        super.run();
        recordQuit();   // æ’æ¡©ï¼šçº¿ç¨‹ç»“æŸ
    }

    public void recordRun() {
        if (LifecycleCollector.enabled && !isRunRecorded) {
            isRunRecorded = true;
            ThreadCollector.onJavaThreadRun(getId());
        }
    }

    public void recordQuit() {
        if (LifecycleCollector.enabled && !isQuitRecorded) {
            isQuitRecorded = true;
            ThreadCollector.onJavaThreadQuit(getId());
        }
    }
}
```

### 2. çº¿ç¨‹æ± æ’æ¡© - BrookExecutors

**åŸå§‹ä»£ç ï¼š**
```java
ExecutorService executor = Executors.newFixedThreadPool(4);
```

**æ’æ¡©åçš„ä»£ç ï¼š**
```java
// é™æ€æ–¹æ³•è°ƒç”¨æ›¿æ¢
ExecutorService executor = BrookExecutors.newFixedThreadPool(4);

// BrookExecutorså®ç°
public class BrookExecutors {
    public static ExecutorService newFixedThreadPool(int nThreads) {
        ExecutorService executorService = Executors.newFixedThreadPool(nThreads);
        if (executorService instanceof ThreadPoolExecutor) {
            // æ’æ¡©ï¼šæ‹¦æˆªThreadFactory
            ThreadPoolExecutorIntercepter.interceptThreadFactory((ThreadPoolExecutor)executorService);
        }
        return executorService;
    }
}

// ThreadFactoryæ‹¦æˆªå™¨
public class ThreadPoolExecutorIntercepter {
    public static void interceptThreadFactory(ThreadPoolExecutor threadPoolExecutor) {
        ThreadFactory threadFactory = threadPoolExecutor.getThreadFactory();
        ThreadFactory proxyThreadFactory = proxyThreadFactory(threadFactory);
        threadPoolExecutor.setThreadFactory(proxyThreadFactory);
    }

    public static ThreadFactory proxyThreadFactory(ThreadFactory threadFactory) {
        ThreadFactoryProxyHandler proxyHandler = new ThreadFactoryProxyHandler(threadFactory);
        return (ThreadFactory)Proxy.newProxyInstance(
            threadFactory.getClass().getClassLoader(), 
            new Class[]{ThreadFactory.class}, 
            proxyHandler
        );
    }

    // åŠ¨æ€ä»£ç†å¤„ç†
    public static class ThreadFactoryProxyHandler implements InvocationHandler {
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            Runnable targetRunnable = (Runnable)args[0];
            RunnableProxyHandler proxyHandler = new RunnableProxyHandler(targetRunnable);
            Runnable proxyRunnable = (Runnable)Proxy.newProxyInstance(
                targetRunnable.getClass().getClassLoader(), 
                new Class[]{Runnable.class}, 
                proxyHandler
            );
            args[0] = proxyRunnable;
            
            Thread thread = (Thread)method.invoke(this.target, args);
            if (thread != null) {
                // æ’æ¡©ï¼šè®°å½•çº¿ç¨‹æ± åˆ›å»ºçš„çº¿ç¨‹
                ThreadCollector.onJavaThreadCreate(
                    Thread.currentThread().getId(), 
                    thread.getId(), 
                    thread.getName(),
                    thread.getPriority()
                );
            }
            return thread;
        }
    }

    // Runnableä»£ç†å¤„ç†
    public static class RunnableProxyHandler implements InvocationHandler {
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            long threadId = Thread.currentThread().getId();
            ThreadCollector.onJavaThreadRun(threadId);    // æ’æ¡©ï¼šçº¿ç¨‹è¿è¡Œ
            Object result = method.invoke(this.target, args);
            ThreadCollector.onJavaThreadQuit(threadId);  // æ’æ¡©ï¼šçº¿ç¨‹ç»“æŸ
            return result;
        }
    }
}
```

### 3. é”ç«äº‰æ’æ¡© - BrookSynchronized

**åŸå§‹ä»£ç ï¼š**
```java
synchronized(obj) {
    // ä¸šåŠ¡é€»è¾‘
}
```

**æ’æ¡©åçš„å­—èŠ‚ç ï¼š**
```java
// æ’æ¡©å‰
MONITORENTER
// ä¸šåŠ¡é€»è¾‘
MONITOREXIT

// æ’æ¡©å
INVOKESTATIC BrookSynchronized.acquireLockBefore()V
MONITORENTER
INVOKESTATIC BrookSynchronized.acquireLockAfter()V
// ä¸šåŠ¡é€»è¾‘
MONITOREXIT
```

**BrookSynchronizedå®ç°ï¼š**
```java
public class BrookSynchronized {
    private static final ThreadLocal<Long> startTimeMillis = new ThreadLocal<Long>() {
        @Override
        protected Long initialValue() {
            return SystemClock.elapsedRealtime();
        }
    };

    public static void acquireLockBefore() {
        startTimeMillis.set(SystemClock.elapsedRealtime());
    }

    public static void acquireLockAfter() {
        Long start = startTimeMillis.get();
        if (start == null) return;
        
        // æ’æ¡©ï¼šè®°å½•é”ç­‰å¾…æ—¶é—´
        LockWaitCollector.onLockAcquire(start, SystemClock.elapsedRealtime());
        startTimeMillis.set(null);
    }
}
```

### 4. synchronizedæ–¹æ³•æ’æ¡©

**åŸå§‹ä»£ç ï¼š**
```java
public synchronized void method() {
    // ä¸šåŠ¡é€»è¾‘
}
```

**æ’æ¡©åçš„ä»£ç ï¼š**
```java
public synchronized void method() {
    BrookSynchronized.acquireLockAfter();  // æ’æ¡©ï¼šæ–¹æ³•å¼€å§‹
    // ä¸šåŠ¡é€»è¾‘
}
```

### 5. Object.wait()æ’æ¡©

**åŸå§‹ä»£ç ï¼š**
```java
obj.wait();
obj.wait(1000);
```

**æ’æ¡©åçš„ä»£ç ï¼š**
```java
// æ–¹æ³•è°ƒç”¨æ›¿æ¢
BrookObject.wait(obj);
BrookObject.wait(obj, 1000);

// BrookObjectå®ç°
public class BrookObject {
    public static void wait(Object object) throws InterruptedException {
        BrookSynchronized.acquireLockBefore();  // æ’æ¡©ï¼šè®°å½•ç­‰å¾…å¼€å§‹
        object.wait();
        BrookSynchronized.acquireLockAfter();   // æ’æ¡©ï¼šè®°å½•ç­‰å¾…ç»“æŸ
    }

    public static void wait(Object object, long timeout) throws InterruptedException {
        BrookSynchronized.acquireLockBefore();
        object.wait(timeout);
        BrookSynchronized.acquireLockAfter();
    }
}
```

### 6. Lockæ¥å£æ’æ¡©

**åŸå§‹ä»£ç ï¼š**
```java
lock.lock();
lock.lockInterruptibly();
```

**æ’æ¡©åçš„ä»£ç ï¼š**
```java
// æ–¹æ³•è°ƒç”¨æ›¿æ¢
BrookLock.lock(lock);
BrookLock.lockInterruptibly(lock);

// BrookLockå®ç°
public class BrookLock {
    public static void lock(Lock lock) {
        BrookSynchronized.acquireLockBefore();  // æ’æ¡©ï¼šè®°å½•é”è·å–å¼€å§‹
        lock.lock();
        BrookSynchronized.acquireLockAfter();   // æ’æ¡©ï¼šè®°å½•é”è·å–ç»“æŸ
    }

    public static void lockInterruptibly(Lock lock) throws InterruptedException {
        BrookSynchronized.acquireLockBefore();
        lock.lockInterruptibly();
        BrookSynchronized.acquireLockAfter();
    }
}
```

### 7. ASMå­—èŠ‚ç æ’æ¡©å®ç°

**synchronizedå—æ’æ¡©ï¼š**
```java
// ProcessCodeVisitor.Processorå®ç°
this.injectSynchronizedBlockProcessor = new ProcessCodeVisitor.Processor() {
    @Override
    public void process(MethodEntity callerMethod, MethodNode methodNode) {
        InsnList insnList = methodNode.instructions;
        AbstractInsnNode currentInsn = insnList.getFirst();
        
        while (currentInsn != null) {
            if (currentInsn.getOpcode() == Opcodes.MONITORENTER) {
                // åœ¨MONITORENTERå‰æ’å…¥
                insnList.insertBefore(currentInsn, new MethodInsnNode(
                    Opcodes.INVOKESTATIC,
                    "com/youku/kuki/brook/thread/proto/BrookSynchronized",
                    "acquireLockBefore", "()V", false
                ));
                
                // åœ¨MONITORENTERåæ’å…¥
                AbstractInsnNode insertAfterNode = (currentInsn.getNext() instanceof LabelNode)
                    ? currentInsn.getNext() : currentInsn;
                insnList.insert(insertAfterNode, new MethodInsnNode(
                    Opcodes.INVOKESTATIC,
                    "com/youku/kuki/brook/thread/proto/BrookSynchronized",
                    "acquireLockAfter", "()V", false
                ));
            }
            currentInsn = currentInsn.getNext();
        }
    }
};
```

**æ–¹æ³•å¼€å§‹å’Œç»“æŸæ’æ¡©ï¼š**
```java
// AppendCodeAtBeginAndEndOfMethodVisitorå®ç°
public class AppendCodeAtBeginAndEndOfMethodVisitor extends ClassVisitor {
    private static class AppendCodeMethodVisitor extends MethodVisitor {
        @Override
        public void visitCode() {
            this.listener.begin(this.mv, this.method);  // æ’æ¡©ï¼šæ–¹æ³•å¼€å§‹
            super.visitCode();
        }

        @Override
        public void visitInsn(int opcode) {
            if (opcode == Opcodes.IRETURN || opcode == Opcodes.LRETURN || 
                opcode == Opcodes.FRETURN || opcode == Opcodes.DRETURN || 
                opcode == Opcodes.ARETURN || opcode == Opcodes.RETURN || 
                opcode == Opcodes.ATHROW) {
                this.listener.end(this.mv, this.method);  // æ’æ¡©ï¼šæ–¹æ³•ç»“æŸ
            }
            super.visitInsn(opcode);
        }
    }
}
```

### 8. Nativeæ–¹æ³•æ’æ¡©

**åŸå§‹ä»£ç ï¼š**
```java
public native void nativeMethod();
```

**æ’æ¡©åçš„ä»£ç ï¼š**
```java
public native void nativeMethod() {
    long startTime = SystemClock.elapsedRealtime();  // æ’æ¡©ï¼šè®°å½•å¼€å§‹æ—¶é—´
    nativeMethodImpl();  // åŸå§‹Nativeè°ƒç”¨
    MethodTraceCollector.onNativeMethodEnd(className, methodName, startTime);  // æ’æ¡©ï¼šè®°å½•ç»“æŸ
}
```

**æ’æ¡©å®ç°ï¼š**
```java
// AppendCodeAtVisitMethodInsnVisitor.Listenerå®ç°
new AppendCodeAtVisitMethodInsnVisitor.Listener() {
    @Override
    public void visitMethodInsn(AppendCodeMethodVisitor adapter, int opcode, String owner,
                                String name, String descriptor, boolean isInterface) {
        MethodVisitor mv = adapter.mv();
        int varIndex = adapter.newLocal(Type.LONG_TYPE);
        
        // æ’æ¡©ï¼šè®°å½•å¼€å§‹æ—¶é—´
        mv.visitMethodInsn(Opcodes.INVOKESTATIC,
            "android/os/SystemClock", "elapsedRealtime", "()J", false);
        mv.visitVarInsn(Opcodes.LSTORE, varIndex);
        
        // åŸå§‹æ–¹æ³•è°ƒç”¨
        adapter.superVisitMethodInsn(opcode, owner, name, descriptor, isInterface);
        
        // æ’æ¡©ï¼šè®°å½•ç»“æŸæ—¶é—´
        mv.visitLdcInsn(owner.replace('/', '.'));
        mv.visitLdcInsn(name);
        mv.visitVarInsn(Opcodes.LLOAD, varIndex);
        mv.visitMethodInsn(Opcodes.INVOKESTATIC,
            "com/youku/kuki/brook/thread/MethodTraceCollector", "onNativeMethodEnd",
            "(Ljava/lang/String;Ljava/lang/String;J)V", false);
    }
}
```

### 9. æ„é€ å‡½æ•°æ›¿æ¢æ’æ¡©

**åŸå§‹ä»£ç ï¼š**
```java
new Thread(runnable);
new Timer();
new HandlerThread("name");
```

**æ’æ¡©åçš„ä»£ç ï¼š**
```java
// æ„é€ å‡½æ•°è°ƒç”¨æ›¿æ¢
new BrookThread(runnable);
new BrookTimer();
new BrookHandlerThread("name");
```

**æ’æ¡©å®ç°ï¼š**
```java
// ReplaceConstructorInvokeVisitorå®ç°
private static class ReplaceConstructorMethodVisitor extends MethodVisitor {
    @Override
    public void visitTypeInsn(int opcode, String type) {
        if (opcode == Opcodes.NEW && this.config.needReplace(type)) {
            // æ›¿æ¢NEWæŒ‡ä»¤çš„ç›®æ ‡ç±»å‹
            super.visitTypeInsn(opcode, this.config.getReplacementOrOrigin(type));
            this.newInsnTypeStack.push(type);
            return;
        }
        super.visitTypeInsn(opcode, type);
    }

    @Override
    public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {
        if (!this.newInsnTypeStack.isEmpty() && 
            opcode == Opcodes.INVOKESPECIAL && 
            name.equals("<init>") && 
            owner.equals(this.newInsnTypeStack.peek())) {
            
            // æ›¿æ¢æ„é€ å‡½æ•°è°ƒç”¨
            String replacedOwner = this.config.getReplacementOrOrigin(owner);
            super.visitMethodInsn(opcode, replacedOwner, name, descriptor, isInterface);
            this.newInsnTypeStack.pop();
            return;
        }
        super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
    }
}
```

è¿™äº›æ’æ¡©å®ç°é€šè¿‡ç¼–è¯‘æ—¶å­—èŠ‚ç æ“ä½œï¼Œåœ¨ä¸ä¿®æ”¹æºä»£ç çš„æƒ…å†µä¸‹ï¼Œå®ç°äº†å¯¹çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸã€é”ç«äº‰ã€æ–¹æ³•è°ƒç”¨ç­‰å…³é”®è¡Œä¸ºçš„ç›‘æ§ï¼Œä¸ºæ€§èƒ½åˆ†æå’Œé—®é¢˜è¯Šæ–­æä¾›äº†è¯¦ç»†çš„æ•°æ®æ”¯æŒã€‚