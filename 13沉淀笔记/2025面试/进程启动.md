### Android App进程启动流程

**核心角色与分工：**
*   **发起进程：** 请求启动新App的进程（如Launcher或另一个App）。
*   **System Server（`system_server`）：** 系统的核心服务进程，其中的**ActivityManagerService（AMS）** 是进程管理的“总指挥”。
*   **Zygote：** 所有Android应用进程的“孵化器”，预加载了通用框架和资源。
*   **新App进程：** 被创建的目标进程。

**完整启动流程：**
1.  **发起创建请求（Binder IPC）**
    *   当需要启动一个组件（如Activity）而其所在进程未运行时，**发起进程**会通过Binder通知**System Server进程**中的AMS
    *   AMS准备新进程所需的参数，如用uid、gid、nice-name等

2.  **连接Zygote（Socket IPC）**
    *   **System Server进程：** 调用`Process.start()`方法，通过**Socket**向Zygote进程发送创建新进程的请求
    *   **使用Socket的原因：** Zygote孵化进程需要调用`fork()`，而`fork()`不支持多线程操作，但Binder通信本身是多线程的，所以使用Socket这一单线程通信机制可以完美避免死锁和状态混乱

3.  **Zygote孵化进程（`fork`与特化）**
    *   Zygote在`ZygoteInit.runSelectLoop()`中监听到请求 → `ZygoteConnection.runOnce()` → `forkAndSpecialize()`
    *   **核心步骤 `forkAndSpecialize()`：**
        *   **`preFork`:** 暂停Zygote内的守护线程（java堆内存整理线程、对线下引用队列线程、析构线程以及监控线程），为`fork`创造一个稳定的单线程环境
        *   **`nativeForkAndSpecialize`:** 调用Linux的`fork()`系统调用，创建出一个Zygote的子进程，这是最核心的一步
        *   **`postForkCommon`:** 在新进程中恢复必要的守护线程。

4.  **新进程初始化（进入App世界）**
    *   新进程进入`ZygoteConnection.handleChildProc()`方法，设置进程名，初始化Binder驱动（打开Binder驱动，启动Binder线程）。
    *   执行 `android.app.ActivityThread.main()` ，这是每个App进程的入口点

5.  **建立系统连接（Binder注册）**
    *   `ActivityThread.main()` 中的核心逻辑，按顺序执行如下：
        *   `Looper.prepareMainLooper()`: **初始化主线程消息队列**
        *   `new ActivityThread()`: 创建主线程管理器
        *   `thread.attach()`: **通过Binder调用`AMS.attachApplication()`**，将新进程的`ApplicationThread`对象（一个Binder代理，可视为进程的“遥控器”）告知AMS
        *   `Looper.loop()`: **启动主线程消息循环**
    *   至此，AMS获得了指挥该App进程的能力
    
android/app/ActivityThread.java
```java
public static void main(String[] args) {  
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain");  
      
    // 1. 初始化 Looper、MessageQueue  
    Looper.prepareMainLooper();  
      
    // 2. 初始化 ActivityThread  
    long startSeq = 0;  
    if (args != null) {  
        for (int i = args.length - 1; i >= 0; --i) {  
            if (args[i] != null && args[i].startsWith(PROC_START_SEQ_IDENT)) {  
                startSeq = Long.parseLong(  
                        args[i].substring(PROC_START_SEQ_IDENT.length()));  
            }  
        }  
    }  
    ActivityThread thread = new ActivityThread();  
      
    // 3. 主要是调用 AMS.attachApplicationLocked() 同步进程信息，并将自己的一个Binder代理（ApplicationThread）传递给AMS，从此，AMS便获得了指挥这个App进程的“遥控器”  
    thread.attach(false, startSeq);  
      
    // 4. 获取主线程的 Handler，这里是 H ，基本上 App 的 Message 都会在这个 Handler 里面进行处理   
    if (sMainThreadHandler == null) {  
        sMainThreadHandler = thread.getHandler();  
    }  
      
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);  
      
    // 5. 初始化完成，Looper 开始工作  
    Looper.loop();  
      
    throw new RuntimeException("Main thread loop unexpectedly exited");  
}
```

6.  **完成应用启动（生命周期回调）**
    *   AMS通过拿到的“遥控器”（`ApplicationThread`），向新进程发送系列Binder指令：
        *   `BIND_APPLICATION`: 触发创建`Application`并调用其`onCreate()`方法
        *   后续指令（如`LAUNCH_ACTIVITY`）：启动最初请求的组件（如Activity）


#### Application创建过程
![[Pasted image 20251018220849.png]]

#### 原理与优势
*   **Copy-on-Write（写时复制）：** Zygote通过`fork()`创建进程，父子进程初始共享内存页。只有当任一进程试图修改内存时，内核才会执行实际复制。这**极大地节省了物理内存占用**
*   **预加载与共享库：** Zygote在启动时预加载了通用的Framework类和资源。所有App进程作为其子进程直接继承这些只读信息，**避免了每个进程重复加载，极大提升了启动效率**
*   **职责分离的架构：**
    *   **AMS**：负责管理和调度（“指挥”）。
    *   **Zygote**：负责进程孵化（“生”）。
    *   **App进程**：负责运行业务逻辑（“干”）。
    架构清晰，效率和稳定性高
注释里面都很清楚，这里就不详细说了，main 函数处理完成之后，主线程就算是正式上线开始工作.
