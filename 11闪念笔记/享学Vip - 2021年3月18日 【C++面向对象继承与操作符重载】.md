日期： 2022-05-07

标签： #学习笔记 #技术 #Android 

学习资料： 
腾讯课堂 - https://ke.qq.com/webcourse/3060320/105200059#taid=13821157516948064&vid=387702298741241216

百度网盘 - https://pan.baidu.com/disk/main?from=homeFlow&_at_=1651480206800#/index?category=all&path=%2F%E5%AD%A6%E4%B9%A0%2F%E4%BA%AB%E5%AD%A6VIP%E8%AF%BE%E7%A8%8B%2F2%E6%9C%9F%2F%E3%80%9007%E3%80%91NDK%2F%EF%BC%8811%EF%BC%892021.3.18%20C%2B%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD--derry

---
<br>

### 一、运算符重载
- **关键字：`operator`**

##### 1、类“外”部的运算符重载

```cpp
#include <iostream>
using namespace std;

class Derry {
private:
	int x, y;

public:
	Derry() {

	}

	Derry(int x, int y) :x(x), y(y) {}

	// set get 函数
	void setX(int x) {
		this->x = x;
	}
	void setY(int y) {
		this->y = y;
	}
	int getX() {
		// this->x  -9; 系统怕你在函数里面 修改了
		return this->x;
	}
	int getY() {
		return this->y;
	}

	// 1. 运算符 + 号的重载（即当 对象1 + 对象2 的写法时，把 + 重载自定义掉）
	// 使用 & 是为了性能的提高，如果没有&，运行 + 运算时，会构建新的副本对象，浪费性能开销
	// 如果增加了& 引用是给这块内存空间取一个别名而已，实质上没有额外创建新对象
	// 设计理念类似Java中的Comparable
	Derry operator + (const Derry& derry1) {
		// this指针 指向当前对象，所以只需要一个
		int x = this->x + derry1.x; // 在类的内部，允许访问私有成员
		int y = this->y + derry1.y; // 在类的内部，允许访问私有成员

		return Derry(x, y);// 【注意】虽然函数弹栈会释放这里栈成员的内存，但是在上层=拷贝逻辑未执行完毕前，该函数不会弹栈
	}

	// 2. 运算符 - 号的重载
	Derry operator - (const Derry& derry1) {
		int x = this->x - derry1.x;
		int y = this->y - derry1.y;

		return Derry(x, y);
	}

	// 3.1 运算符 ++ 号的重载（++对象）
	void operator ++() {
		this->x = this->x + 1;
		this->y = this->y + 1;
	}
	// 3.2 运算符 ++ 号的重载（对象++）
	void operator ++ (int) {
		this->x = this->x + 1;
		this->y = this->y + 1;
	}


	// 4.1 "单个"的输出运算符 << 的重载
	// ostream 输出
	friend void operator << (ostream& _START, Derry derry1) {
		_START << "单个cout，开始输出: x-" << derry1.x << " , y-" << derry1.y << endl;
	}

	// 4.2 "多个"的输出运算符 >> 的重载
	// ostream 输出
	friend ostream& operator >> (ostream& _START, const Derry& derry) {
		_START << "多个cout，开始输出: x-" << derry.x << " , y-" << derry.y << endl;
		return _START;

		// 实现上，与"单个"的区别在于，要将入参 _START return出去，
		// 类似 RxJava 链式调用， .操作符.操作符.操作符 每次都是放回this
	}

	// 5. "多个"的输入运算符 >> 的重载
	// istream 输入
	friend istream& operator >> (istream& _START, Derry& derry) {
		// 接收用户的输入，把输入的信息，给x、y

		cout << "请输入x:";
		_START >> derry.x;

		cout << "请输入y:";
		_START >> derry.y;

		// 下面的写法也可以，但是可读性不好，简化了
		// _START >> derry.x >> derry.y;

		return _START;
	}
};

int main() {
	Derry derry1(1000, 2000);
	Derry derry2(3000, 4000);
	cout << "derry1: x-" << derry1.getX() << " , y-" << derry1.getY() << endl;
	cout << "derry2: x-" << derry2.getX() << " , y-" << derry2.getY() << endl;

	cout << endl;

	Derry result1 = derry1 + derry2;

	cout << "result1 = derry1 + derry2: x-" << result1.getX() << " , y-" << result1.getY() << endl;

	Derry result2 = derry2 - derry1;

	cout << "result2 = derry2 - derry1: x-" << result2.getX() << " , y-" << result2.getY() << endl;

	cout << endl;

	Derry result3(1, 2);
	cout << "result3: x-" << result3.getX() << " , y-" << result3.getY() << endl;
	result3++;
	++result3;

	cout << "result3++、++result3: x-" << result3.getX() << " , y-" << result3.getY() << endl;

	cout << endl;

	cout << derry1; // 单个的cout输出

	cout << endl;

	cout >> derry1 >> derry1 >> derry1 >> derry1; // 多个的cout输出

	cout << endl;

	/*
	 * cout = C++输出
	 * cin = C++输入
	 */
	Derry derryInput;
	cin >> derryInput; // istream输入运算符 >> 是被我们自己重载的
	cout << "你输入的是x：" << derryInput.getX() << endl;
	cout << "你输入的是y：" << derryInput.getY() << endl;

	return 0;
}
```

<br>

##### 2、类“内”部的运算符重载

