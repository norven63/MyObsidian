日期： 2022-04-30

标签： #学习笔记 #技术 #Android 

学习资料： 
腾讯课堂 - https://ke.qq.com/webcourse/3060320/105200059#taid=13821093092438624&vid=387702298740987865

百度网盘 - https://pan.baidu.com/disk/main?from=homeFlow#/index?category=all&path=%2F%E5%AD%A6%E4%B9%A0%2F%E4%BA%AB%E5%AD%A6VIP%E8%AF%BE%E7%A8%8B%2F2%E6%9C%9F%2F%E3%80%9007%E3%80%91NDK%2F%EF%BC%8808%EF%BC%892021.3.11%20C%2B%2B%E8%AF%AD%E8%A8%80%E7%B1%BB%E4%B8%AD%E5%90%84%E4%B8%AA%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86%EF%BC%88NDK%E7%AC%AC%E5%85%AB%E8%8A%82%E8%AF%BE%EF%BC%89--derry%E8%80%81%E5%B8%88

---
<br>

### 一、构造函数、析构函数
- `new` 、 `delete` 是一套，会调用构造函数 与 析构函数【C++标准规范】
- `malloc`、`free` 是一套，不调用构造函数 与 析构函数【C的范畴，虽然不推荐，但是也是可以的】

##### 1、头文件
```cpp
#pragma once
#include <iostream>
#include <string.h>
using namespace std;

class Student {


	// 私有属性
private:
	char* name;
	int age;


	/*
	 * 【一、构造函数】
	 */
public:

	 // 1. 空参构造函数
	Student();

	// 2. 有参构造函数
	Student(char* name, int age);

	// 3. 构造函数嵌套调用
	// :Student(name, 87)的写法，等价于：1.先调用两个参数的构造函数 2.再调用当前函数
	Student(char* name);

	// 4. 构造函数签名处直接给成员变量赋值
	// :age(age) 等价于：this->age = age;
	Student(int age);


	/*
	 * 【二、析构函数】
	 */
	 // 析构函数在对象被回收时，执行内存释放工作
	 // 当调用 delete 的时候，析构函数就会被执行
	 // free不会执行析构函数，不可用来释放对象内存
	~Student();


	/*
	 * 【三、set\get 函数】
	 */
public:
	int getAge();

	char* getName();

	void setAge(int age);

	void setName(char* name);
};
```

##### 2、实现文件
```cpp
#include "Student.h"

/*
 * 【一、构造函数】
 */
 // 1. 空参构造函数
Student::Student() {
	cout << "空参数构造函数" << endl;
}

// 2. 有参构造函数
Student::Student(char* name, int age) {
	// this->name = name;

	// 堆区
	this->name = (char*)(malloc(sizeof(char*) * 10));
	strcpy(this->name, name);

	this->age = age;
	cout << "两个参数的构造函数" << endl;
}

// 3. 构造函数嵌套调用
// :Student(name, 87)的写法，等价于：1.先调用两个参数的构造函数 2.再调用当前函数
Student::Student(char* name) :Student(name, 87) {
	cout << "一个参数的构造函数" << endl;
	this->name = name;
}

// 4. 构造函数签名处直接给成员变量赋值
// :age(age) 等价于：this->age = age;
Student::Student(int age) :age(age) {
	cout << "一个参数的构造函数" << endl;
}


/*
 * 【二、析构函数】
 */
 // 析构函数在对象被回收时，执行内存释放工作
 // 当调用 delete 的时候，析构函数就会被执行
 // free不会执行析构函数，不可用来释放对象内存
Student::~Student() {
	cout << this->name << "析构函数" << endl;

	// 必须释放堆区开辟的成员
	if (this->name) {
		free(this->name); // 释放内存
		this->name = NULL; // 执行NULL的地址，避免出现悬空指针
	}
}


/*
 * 【三、公开的 set\get 函数】
 */
int Student::getAge() {
	return this->age;
}

char* Student::getName() {
	return this->name;
}

void Student::setAge(int age) {
	this->age = age;
}

void Student::setName(char* name) {
	this->name = name;
}
```

##### 3、调用示例
```cpp
#include <stdio.h>
#include "Student.h"

int main2() {
	//【1. 栈空间开辟】

	 // 1.1 调用空参构造函数
	Student stu1;
	stu1.setAge(34);
	stu1.setName("李元霸");
	cout << "name:" << stu1.getName() << ", age:" << stu1.getAge() << endl << endl;

	// 1.2 调用有参构造函数
	Student stu2("雄霸", 30);
	cout << "name:" << stu2.getName() << ", age:" << stu2.getAge() << endl << endl;


	// 【2. 堆空间开辟】

	// 使用new声明
	Student* stu3 = new Student("杜子腾");
	cout << "name:" << stu3->getName() << ", age:" << stu3->getAge() << endl << endl;

	// 使用delete释放
	delete stu3; // delete与new成对出现，释放对象空间
	// free(stu3); // 【！！！错误写法】这样调用不会执行析构函数


	// 【3. ！！！错误写法：malloc开辟】
	// malloc不会调用执行构造函数，即不会执行对象初始化
	Student* stu4 = (Student*)malloc(sizeof(Student));
	free(stu4);

	return 0;
}
```
