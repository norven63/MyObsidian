日期： 2022-04-30

标签： #学习笔记 #技术 #Android 

学习资料： 
腾讯课堂 - https://ke.qq.com/webcourse/3060320/105200059#taid=13821093092438624&vid=387702298740987865

百度网盘 - https://pan.baidu.com/disk/main?from=homeFlow#/index?category=all&path=%2F%E5%AD%A6%E4%B9%A0%2F%E4%BA%AB%E5%AD%A6VIP%E8%AF%BE%E7%A8%8B%2F2%E6%9C%9F%2F%E3%80%9007%E3%80%91NDK%2F%EF%BC%8808%EF%BC%892021.3.11%20C%2B%2B%E8%AF%AD%E8%A8%80%E7%B1%BB%E4%B8%AD%E5%90%84%E4%B8%AA%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86%EF%BC%88NDK%E7%AC%AC%E5%85%AB%E8%8A%82%E8%AF%BE%EF%BC%89--derry%E8%80%81%E5%B8%88

---
<br>

### 一、构造函数、析构函数

```cpp
class Student {

// 公开的构造函数
public:
	/*
	 * 【一、构造函数】
	 */
	 // 1. 空参构造函数
	Student() {
		cout << "空参数构造函数" << endl;
	}

	// 2. 有参构造函数
	Student(char* name, int age) {
		// this->name = name;

		// 堆区
		this->name = (char*)(malloc(sizeof(char*) * 10));
		strcpy(this->name, name);

		this->age = age;
		cout << "两个参数的构造函数" << endl;
	}

	// 3. 构造函数嵌套调用
	// :Student(name, 87)的写法，等价于：1.先调用两个参数的构造函数 2.再调用当前函数
	Student(char* name) :Student(name, 87) {
		cout << "一个参数的构造函数" << endl;
		this->name = name;
	}

	// 4. 构造函数签名处直接给成员变量赋值
	// :name(name) 等价于：this->name = name;
	Student(char* name) :name(name) {
		cout << "一个参数的构造函数" << endl;
	}


	/*
	 * 【二、析构函数】
	 */
	 // 析构函数在对象被回收时，执行内存释放工作
	 // 当调用 delete 的时候，析构函数就会被执行
	 // free不会执行析构函数，不可用来释放对象内存
	~Student() {
		cout << "析构函数" << endl;

		// 必须释放堆区开辟的成员
		if (this->name) {
			free(this->name); // 释放内存
			this->name = NULL; // 执行NULL的地址，避免出现悬空指针
		}
	}

// 私有属性
private:
	char* name;
	int age;

// 公开的 set\get 函数
public:
	int getAge() {
		return this->age;
	}

	char* getName() {
		return this->name;
	}

	void setAge(int age) {
		this->age = age;
	}

	void setName(char* name) {
		this->name = name;
	}
};
```
